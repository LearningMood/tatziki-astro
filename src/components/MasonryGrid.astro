---
const { projects, miniProjects = [] } = Astro.props;

const sizePatterns = {
  square: { cols: 8, rows: 8 }, //+2 pourle texte ?
  portrait: { cols: 7, rows: 10 },
  landscape: { cols: 10, rows: 7 },
  wide: { cols: 12, rows: 8 },
  tall: { cols: 6, rows: 12 },
  feat: { cols: 12, rows: 9 },
  mini: { cols: 5, rows: 6 },
};

// Assigner des tailles de façon pseudo-aléatoire mais équilibrée -->
const sizes = [
  "square",
  "portrait",
  "landscape",
  "wide",
  "tall",
  "feat",
  "mini",
];
let sizeIndex = 0;
const projectsWithGrid = projects.map((project, index) => {
  // Utiliser la taille définie ou en assigner une
  const gridSize = project.data.gridSize || "landscape";
  const span = project.data.gridSpan || sizePatterns[gridSize];
  sizeIndex++;

  return {
    ...project,
    gridSize,
    gridSpan: span,
    animationDelay: (index % 10) * 0.1 // Délai en cascade, reset tous les 10
  };
});
---

<div class="masonry-grid">
  {
    projectsWithGrid.map((project, index) => {
      const { slug } = project;
      const { title, thumbnail, categories, couleur } = project.data;
      const { gridSpan, gridSize, animationDelay  } = project;

      return (
        <article
          class={`grid-item size-${gridSize}`}
          style={`
          --cols: ${gridSpan.cols};
          --rows: ${gridSpan.rows};
          --color: ${couleur || "#3085a3"};
          --delay: ${animationDelay}s;
        `}
        data-scroll-animate
        >
          <a href={`/projects/${slug}`} class="item-projet">
            <figure class="item-projet-image">
              <img src={thumbnail} alt={title} loading="lazy" />
              <figcaption class="item-overlay">
                <span class="item-cta">Voir le projet</span>
              </figcaption>
            </figure>

            <div class="item-projet-info">
              <h3>{title}</h3>
              {categories && categories.length > 0 && (
                <div class="categories">
                  {categories.slice(0, 2).map((cat) => (
                    <span class="category">{cat}</span>
                  ))}
                </div>
              )}
            </div>
          </a>
        </article>
      );
    })
  }
</div>
<script>
  // Observer pour déclencher l'animation au scroll
  const animateOnScroll = () => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Ajouter la classe qui déclenche l'animation
            entry.target.classList.add('is-visible');
            // Arrêter d'observer cet élément (animation unique)
            observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: 0.1, // Se déclenche quand 10% de l'élément est visible
        rootMargin: '50px' // Commence un peu avant d'être visible
      }
    );
    
    // Observer tous les éléments avec l'attribut data-scroll-animate
    const elements = document.querySelectorAll('[data-scroll-animate]');
    elements.forEach(el => observer.observe(el));
  };
  
  // Lancer quand le DOM est prêt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', animateOnScroll);
  } else {
    animateOnScroll();
  }
</script>