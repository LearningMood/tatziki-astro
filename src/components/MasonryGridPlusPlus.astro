---
import { fillerConfig } from "../content/data-filler";
import FillerItem from "./FillerItem.astro";

const { projects, miniProjects = [] } = Astro.props;

// Patterns pour projets principaux (sur 24 colonnes)
const mainPatterns = {
    square: { cols: 8, rows: 8 }, //+2 pourle texte ?
    portrait: { cols: 7, rows: 10 },
    landscape: { cols: 10, rows: 7 },
    wide: { cols: 12, rows: 8 },
    tall: { cols: 6, rows: 12 },
    feat: { cols: 12, rows: 9 },
};

// Mini-projets de remplissage
const fillerPatterns = [
    { cols: 6, rows: 3 },
    { cols: 4, rows: 4 },
    { cols: 5, rows: 5 },
    { cols: 4, rows: 5 },
    { cols: 5, rows: 4 },
];

// Distribuer les projets principaux
const mainProjectsWithGrid = projects.map((project, index) => {
    const patterns = ["square", "wide", "tall", "large", "feat", "landscape"];
    const gridSize = project.data.gridSize || patterns[index % patterns.length];
    return {
        ...project,
        gridSpan: mainPatterns[gridSize],
        gridSize,
        type: "projet", // les projets = type principal (sinon petti filler intercalé)
    };
});

// Intercaler des mini-projets (environ 1 pour 3 principaux)
const allItems = [];
let fillerIndex = 0;

mainProjectsWithGrid.forEach((project, index) => {
    allItems.push({ ...project, type: "projet" });

    // Ajouter un filler tous les 3 projets
    if (index % 3 === 1 && fillerIndex < fillerConfig.items.length) {
        const pattern =
            fillerConfig.patterns[fillerIndex % fillerConfig.patterns.length];
        allItems.push({
            type: "filler",
            data: fillerConfig.items[fillerIndex],
            gridSpan: pattern,
        });
        fillerIndex++;
    }
});

// Juste après la boucle forEach
console.log('Projets:', allItems.filter(i => i.type === 'projet').length);
console.log('Fillers:', allItems.filter(i => i.type === 'filler').length);
console.log('Premier filler:', allItems.find(i => i.type === 'filler'));


---

<div class="masonry-grid">
    {
        allItems.map((item, index) => {
            if (item.type === "projet") {
                // Projet principal
                const { slug } = item;
                const { title, thumbnail, couleur, categories } = item.data;
                const { gridSpan, gridSize } = item;

                return (
                    <article
                        class={`grid-item project size-${gridSize}`}
                        style={`
            --cols: ${gridSpan.cols};
            --rows: ${gridSpan.rows};
            --color: ${couleur || "#3085a3"};
            --delay: ${(index % 10) * 0.1}s;
          `}
                        data-scroll-animate
                    >
                        <a href={`/projects/${slug}`}>
                            <figure class="item-projet-image">
                                <img
                                    src={thumbnail}
                                    alt={title}
                                    loading="lazy"
                                />
                                <figcaption class="item-overlay">
                                    <span class="item-cta">Voir le projet</span>
                                </figcaption>
                            </figure>
                            <div class="item-projet-info">
                                <h3>{title}</h3>
                                {categories && categories.length > 0 && (
                                    <div class="categories">
                                        {categories.slice(0, 2).map((cat) => (
                                            <span class="category">{cat}</span>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </a>
                    </article>
                );
            } else {
                return (
                <FillerItem
                    filler={item.data}
                    gridSpan={item.gridSpan}
                    delay={(index % 10) * 0.1}
                />
                )
            }
        })
    }
</div>

<script>
    // Animation au scroll (même que précédemment)
    const animateOnScroll = () => {
        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add("is-visible");
                        observer.unobserve(entry.target);
                    }
                });
            },
            { threshold: 0.1, rootMargin: "50px" },
        );

        document.querySelectorAll("[data-scroll-animate]").forEach((el) => {
            observer.observe(el);
        });
    };

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", animateOnScroll);
    } else {
        animateOnScroll();
    }
</script>
